// typedef btc_bool (*entropy_source)(uint8_t *buf, uint32_t len, const uint8_t update_seed);

// btc_bool generate_mnemonics(size_t word_count, vector *words_out, entropy_source ent);

// btc_bool generate_master_seed(vector *words,
//                               const char *password,
//                               uint8_t seed_out[SHA512_DIGEST_LENGTH]);

// btc_bool recover_master_seed(vector *mnemonics,
//                              const char *password,
//                              uint8_t seed_out[SHA512_DIGEST_LENGTH]);

// btc_bool validate_checksum(vector *mnemonics);

// https://iancoleman.io/bip39/#english

use crate::entropy::EntropySource;
// use hex;
use sha2::{Digest, Sha256};
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
use std::vec::Vec;
use to_binary::BinaryString;

pub fn generate_mnemonics(
    word_count: usize,
    ent: &dyn EntropySource,
) -> Result<Vec<String>, String> {
    let entropy_len;
    match word_count {
        12 | 15 | 18 | 21 | 24 => entropy_len = word_count / 3 * 32,
        _ => return Err(format!("Invalid word_count {}", word_count)),
    };

    println!("Entropy len {}", entropy_len);

    let mut out = ent.get_random_bits(entropy_len);
    println!("Entropy {:?}", out);

    // let hex_str = format!("{:x}", out);
    // TODO: what about endianess here?
    // Sha256::digest(&out);
    let mut hasher = Sha256::new();

    for el in out.iter() {
        hasher.update(el.to_be_bytes());
    }

    let ent_hash = hasher.finalize();
    println!("hash {:x}", ent_hash);

    let ent_hash = BinaryString::from(ent_hash.as_slice());

    println!("hash bin {}", ent_hash);
    // Change entropy bytes to bin string
    let mut out = BinaryString::from(out);

    let check_sum_len = entropy_len / 32;

    println!("checksum len {}", check_sum_len);

    // A checksum is generated by taking the first
    //  ENT / 32
    // bits of its SHA256 hash. This checksum is appended to the end of the initial entropy.
    // Make it more pythonic, errr rustonic?
    for (i, el) in ent_hash.0.chars().enumerate() {
        if i == check_sum_len {
            break;
        }

        out.0.push(el);
    }

    println!("out + cs {}", out.0.len());

    // Next, these concatenated bits are split into groups of 11 bits,
    // each encoding a number from 0-2047, serving as an index into a wordlist.
    println!("Bin string: {}", out);

    let mut word_indices = vec![];
    let mut index = String::new();
    for (i, el) in out.0.chars().enumerate() {
        if i > 0 && i % 11 == 0 {
            word_indices.push(index);
            index = String::new();
        }

        index.push(el);
    }

    word_indices.push(index);

    println!("word indices: {:?}", word_indices);

    let mut word_indices_dec = vec![];
    for bin_idx in word_indices {
        word_indices_dec.push(usize::from_str_radix(&bin_idx, 2).unwrap());
    }

    println!("word indices dec: {:?}", word_indices_dec);

    // Convert indices to actual words
    let mut filename = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    filename.push("src/bip39/english.txt");

    let reader = BufReader::new(File::open(filename).unwrap());

    let mut mnemonics = vec![];

    // Read the file line by line using the lines() iterator from std::io::BufRead.
    for (index, line) in reader.lines().enumerate() {
        let line = line.unwrap();
        if word_indices_dec.contains(&(index)) {
            mnemonics.push((index, line));
        }
    }

    println!("Mnemonics {:?}", mnemonics);

    // Iterate over indices, find it in mnemonics, return making them ordered correctly
    let mnemonics: Vec<String> = word_indices_dec
        .iter()
        .map(
            |idx| match mnemonics.iter().find(|(place, _)| place == idx) {
                Some((_, word)) => String::from(word), // TODO: this is a copy, is there any way to make a move?
                None => panic!(format!("Index '{}' does not match any memo", idx)), // TODO: how to return from a function?
            },
        )
        .collect();

    println!("RESULT {:?}", mnemonics);
    Ok(mnemonics)

    // TODO: use proper err handling
}

#[cfg(test)]
mod tests {

    use super::*;

    struct DummyEntropy {}

    impl EntropySource for DummyEntropy {
        fn get_random_bits(&self, _count: usize) -> Vec<u8> {
            let input = "d5a58c5fded9ac099f432a253dbffb68";

            let decoded = hex::decode(input).expect("Decoding failed");
            return decoded;
        }
    }

    #[test]
    fn fiddling_around() {
        // SHA256
        let mut hasher = Sha256::new();

        // https://emn178.github.io/online-tools/sha256.html
        // 0x11 -> 4a64a107f0cb32536e5bce6c98c393db21cca7f4ea187ba8c4dca8b51d4ea80a
        // BIG ENDIAN!
        hasher.update(0x11002233_u32.to_be_bytes());
        println!("hash {:x}", hasher.finalize());

        // Converting hex strng to array of bytes
        let decoded = hex::decode("d5a58c5fded9ac099f432a253dbffb68").unwrap();

        let mut hasher = Sha256::new();
        hasher.update(decoded);
        println!("hash of string {:x}", hasher.finalize());
    }

    #[test]
    fn sha256_calculation_works() {
        let ent = DummyEntropy {};

        let mut hasher = Sha256::new();
        hasher.update(ent.get_random_bits(12));

        assert_eq!(
            "af6d1c421d3fc9a770c960c6552c22d25d0f6d2300c437a750e9f607f091ff9a",
            format!("{:x}", hasher.finalize())
        );
    }

    #[test]
    fn invalid_word_count() {
        assert_eq!(
            Err("Invalid word_count 69".to_string()),
            generate_mnemonics(69, &DummyEntropy {})
        );
    }

    #[test]
    fn valid_word_count() {
        println!("env: {}", env!("CARGO_MANIFEST_DIR"));

        assert_eq!(
            Ok(vec![
                // TODO: da fuck
                "stick".to_string(),
                "cluster".to_string(),
                "blood".to_string(),
                "sad".to_string(),
                "onion".to_string(),
                "age".to_string(),
                "laptop".to_string(),
                "grab".to_string(),
                "cement".to_string(),
                "unknown".to_string(),
                "yard".to_string(),
                "spend".to_string()
            ]),
            generate_mnemonics(12, &DummyEntropy {})
        );
    }
}
